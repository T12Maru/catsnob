// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: shouts.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createShouts = `-- name: CreateShouts :one
insert into shouts (id, created_at, updated_at, user_id, review_id, title, shout_text)
values (
	gen_random_uuid(),
	NOW(),
	NOW(),
	$1,
	$2,
	$3,
	$4
)
returning id, created_at, updated_at, user_id, review_id, title, shout_text
`

type CreateShoutsParams struct {
	UserID    uuid.UUID
	ReviewID  uuid.UUID
	Title     string
	ShoutText string
}

func (q *Queries) CreateShouts(ctx context.Context, arg CreateShoutsParams) (Shout, error) {
	row := q.db.QueryRowContext(ctx, createShouts,
		arg.UserID,
		arg.ReviewID,
		arg.Title,
		arg.ShoutText,
	)
	var i Shout
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.ReviewID,
		&i.Title,
		&i.ShoutText,
	)
	return i, err
}

const deleteShout = `-- name: DeleteShout :exec
DELETE FROM shouts 
WHERE shouts.id = $1
`

func (q *Queries) DeleteShout(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteShout, id)
	return err
}

const getShoutByReview = `-- name: GetShoutByReview :many
SELECT u.img_url, u.name, u.id AS user_id, s.title, s.shout_text, s.created_at, s.id
FROM shouts s
JOIN users u ON u.id = s.user_id
WHERE s.review_id = $1
ORDER BY s.created_at DESC
`

type GetShoutByReviewRow struct {
	ImgUrl    string
	Name      string
	UserID    uuid.UUID
	Title     string
	ShoutText string
	CreatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) GetShoutByReview(ctx context.Context, reviewID uuid.UUID) ([]GetShoutByReviewRow, error) {
	rows, err := q.db.QueryContext(ctx, getShoutByReview, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShoutByReviewRow
	for rows.Next() {
		var i GetShoutByReviewRow
		if err := rows.Scan(
			&i.ImgUrl,
			&i.Name,
			&i.UserID,
			&i.Title,
			&i.ShoutText,
			&i.CreatedAt,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShoutByUserReview = `-- name: GetShoutByUserReview :one
SELECT id, created_at, updated_at, user_id, review_id, title, shout_text FROM shouts
WHERE review_id = $1 and user_id = $2
`

type GetShoutByUserReviewParams struct {
	ReviewID uuid.UUID
	UserID   uuid.UUID
}

func (q *Queries) GetShoutByUserReview(ctx context.Context, arg GetShoutByUserReviewParams) (Shout, error) {
	row := q.db.QueryRowContext(ctx, getShoutByUserReview, arg.ReviewID, arg.UserID)
	var i Shout
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.ReviewID,
		&i.Title,
		&i.ShoutText,
	)
	return i, err
}

const getShoutsByAlbum = `-- name: GetShoutsByAlbum :many
SELECT id, created_at, updated_at, user_id, review_id, title, shout_text FROM shouts
WHERE review_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetShoutsByAlbum(ctx context.Context, reviewID uuid.UUID) ([]Shout, error) {
	rows, err := q.db.QueryContext(ctx, getShoutsByAlbum, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shout
	for rows.Next() {
		var i Shout
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.ReviewID,
			&i.Title,
			&i.ShoutText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShout = `-- name: UpdateShout :exec
UPDATE shouts
SET title = $1, 
shout_text = $2, 
updated_at = $3
WHERE id = $4
`

type UpdateShoutParams struct {
	Title     string
	ShoutText string
	UpdatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) UpdateShout(ctx context.Context, arg UpdateShoutParams) error {
	_, err := q.db.ExecContext(ctx, updateShout,
		arg.Title,
		arg.ShoutText,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
